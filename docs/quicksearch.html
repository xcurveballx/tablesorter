<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"tablesorter.js.html":{"id":"tablesorter.js.html","title":"Source: tablesorter.js","body":" DocStrap Namespaces TablesorterTablesorterIIFE Source: tablesorter.js /*** * The only plugin's dependency - jQuery. It is required before * creating the plugin. */ var jQuery = require(\"jquery\"); /** * There is an IIFE around the plugin. * The IIFE contains several helper functions. * The plugin gets assigned to `$.fn.tablesorter`. * @namespace TablesorterIIFE * @author Curveball &lt;x.curveball.x@gmail.com&gt; * @license MIT * */ (function($, window, document, undefined) { \"use strict\"; $.fn._init = $.fn.init; /** * Makes possible to get selector string later by attaching it to the jQuery object. * Wrapper around original init() function. * @function TablesorterIIFE~init * @param {string|*} selector selector string * @param {object} context an object serving as context for selectors search. The match will be searched for in its children instead of the entire page. * @param {object} root usually $(document). * @returns {object} a jQuery object */ $.fn.init = function(selector, context, root) { return (typeof selector === 'string') ? new $.fn._init(selector, context, root).data('selector', selector) : new $.fn._init(selector, context, root); }; /** * Gets selector string passed to the plugin. * @function TablesorterIIFE~getSelector * @returns {string} selector string passed to the plugin. */ $.fn.getSelector = function() { return $(this).data('selector'); }; /** * The plugin function assigned to `$.fn.tablesorter`. * Below go inner helper functions inside the plugin. * @namespace Tablesorter * @author Curveball &lt;x.curveball.x@gmail.com&gt; * @license MIT * @param {object.&lt;string, *&gt;} [options] object passed to the plugin upon calling * @returns {object} returns collection of matched elements. */ $.fn.tablesorter = function(options) { var settings = $.extend({}, $.fn.tablesorter.settings, options); var selector = $(this).getSelector(), ths = \" .\" + settings.tablesorterTitlesClass, trs = \" .\" + settings.tablesorterGroupsClass, cells = $(selector + ths)[0].cells, columns = settings.tablesorterColumns, curIndex = null, curType = null, curOrder = null, curElem = null, busy = false; /** * Handles clicks on columns' headers. Does some checks and invokes row sorting. * @function Tablesorter~tablesorter * @param {MouseEvent} event event object corresponding to click on controls * @returns {undefined} */ function tablesorter(event) { if(busy || !$(event.target).hasClass('sortable')) return; toggleBusyFlag(); curElem = $(event.target); curOrder = curElem.data('sortOrder'); curIndex = getColIndex(); curType = getValuesType(); if(curIndex === null || (curType !== 'number' &amp;&amp; curType !== 'string')) return; curElem.removeClass(curOrder === 'asc' ? 'desc' : 'asc').addClass(curOrder); sortRows(); toggleSortingOrderForCol(); toggleBusyFlag(); } /** * Toggles plugin's busy flag. * @function Tablesorter~toggleBusyFlag * @returns {undefined} */ function toggleBusyFlag() { busy = busy === true ? false : true; } /** * Toggles column's sorting order flag. * @function Tablesorter~toggleSortingOrderForCol * @returns {undefined} */ function toggleSortingOrderForCol() { if(curElem.data('sortOrder') === 'desc') { curElem.data('sortOrder', 'asc'); } else { curElem.data('sortOrder', 'desc'); } } /** * Sorts table rows. * @function Tablesorter~sortRows * @returns {undefined} */ function sortRows() { var rowsBlocks = $(selector + trs); $.each(rowsBlocks, function(index, rowsBlock) { var rows = $(rowsBlock).find(\"tr\"); if(curType === 'number') { rows.sort(sortAsNumbers); } else { rows.sort(sortAsStrings); } $(rowsBlock).empty().append(rows); }); } /** * Sorting function. Compares two rows' cells with numeric content. * @function Tablesorter~sortAsNumbers * @param {HTMLTableRowElement} rowA one row object * @param {HTMLTableRowElement} rowB another row object * @returns {number} number, depending on what value is greater given the sorting order. */ function sortAsNumbers(rowA, rowB) { var valA = parseFloat(rowA.cells[curIndex].textContent), valB = parseFloat(rowB.cells[curIndex].textContent); if(curOrder === 'asc') return (valA &gt; valB) ? 1 : (valA &lt; valB) ? -1 : rowA.sectionRowIndex - rowB.sectionRowIndex; if(curOrder === 'desc') return (valB &gt; valA) ? 1 : (valB &lt; valA) ? -1 : rowA.sectionRowIndex - rowB.sectionRowIndex; } /** * Sorting function. Compares two rows' cells with textual content. * @function Tablesorter~sortAsStrings * @param {HTMLTableRowElement} rowA one row object * @param {HTMLTableRowElement} rowB another row object * @returns {number} number, depending on what value is greater given the sorting order. */ function sortAsStrings(rowA, rowB) { var valA = rowA.cells[curIndex].textContent, valB = rowB.cells[curIndex].textContent; if(curOrder === 'asc') return (valA &gt; valB) ? 1 : (valA &lt; valB) ? -1 : rowA.sectionRowIndex - rowB.sectionRowIndex; if(curOrder === 'desc') return (valB &gt; valA) ? 1 : (valB &lt; valA) ? -1 : rowA.sectionRowIndex - rowB.sectionRowIndex; } /** * Gets column values' datatype. * @function Tablesorter~getValuesType * @returns {string} column values' datatype. */ function getValuesType() { return $.isNumeric($(selector + trs + \" tr\")[0].cells[curIndex].textContent) ? 'number' : 'string'; } /** * Gets column's index. * @function Tablesorter~getColIndex * @returns {number} column's index. */ function getColIndex() { var allths = curElem[0].parentElement.cells, colIndex = null; $.each(allths, function(index, cell) { if(curElem[0] === cell) colIndex = index; $(cell).removeClass( \"desc asc\" ); }); return colIndex; } (function() { if(columns.length === 0) return; for(var i = 0; i &lt; columns.length; i++) { $(cells[columns[i].col]).addClass('sortable').data('sortOrder', columns[i].order); } $(\"body\").on( \"click\", selector + ths, function(event) { tablesorter(event); }); })(); return this; }; /*** Plugin's default settings*/ $.fn.tablesorter.settings = { tablesorterTitlesClass: 'tsTitles', tablesorterGroupsClass: 'tsGroup', tablesorterColumns: [] }; })(jQuery, window, document); × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces TablesorterTablesorterIIFE Namespaces Namespaces Tablesorter TablesorterIIFE × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces TablesorterTablesorterIIFE Tablesorter TableSorter is a jQuery plugin to sort tabular data in the web UI. It requires jQuery and consists of 3 cornerstones - markup, styles and javascript. While styles and javascript parts are provided out of the box, making the right markup is of plugin users' concern. More on this below. It can sort table's content as a whole by some (all, if you wish) columns values in ASC or DESC order. Also you can divide all the rows into groups and rows will be sorted within those groups. How to import? Use npm i @curveballerpacks/tablesorter to install the package. To include the plugin in your bundles: The Sass preprocessor is used for styles. The source file can be imported into your styles via @import '@curveballerpacks/tablesorter/src/sass/tablesorter' and then processed and bundled into your styles. It is worth mentioning that you should set the path for your bundler. For example, for gulp-sass it might look like: ... .pipe(sass({ outputStyle: 'compressed', includePaths: ['node_modules'] }).on('error', sass.logError)) ... or just indicate the full path inside sass @import statement. Tablesorter makes use of Node's modules. It requires its only dependency - jQuery - and can be required itself in your script via require(\"@curveballerpacks/tablesorter\"); NPM will manage possible duplicates/conflicts of jQuery versions in its dependency graph mostly on its own. Usage The table itself must have tablesorter class. The control row (&lt;tr&gt; with &lt;th&gt;-s) should have tsTitles class (customizable via settings) and the data should be placed inside &lt;tbody&gt; with tsGroup class (customizable via settings). In this simple case the 1st and 8st columns of the table will become \"sortable\" with indicated initial sorting order. In other words, after clicking, for example, on the 1st column's header the table rows will be sorted by the 1st column values in the given order (desc). $(\"table.example1\").tablesorter({tablesorterColumns: [{col: 0, order: 'desc'}, {col: 7, order: 'asc'}]}); Settings Besides tablesorterColumns, it is possible, as mentioned above, to pass into the plugin tablesorterTitlesClass (defaults to 'tsTitles') and tablesorterGroupsClass (defaults to 'tsGroup') settings with corresponding changes in the page markup. More examples Examples in action and more detailed explanation can be found on codepen or example page inside this package. × Search results Close "},"Tablesorter.html":{"id":"Tablesorter.html","title":"Namespace: Tablesorter","body":" DocStrap Namespaces TablesorterTablesorterIIFE Namespace: Tablesorter Tablesorter The plugin function assigned to $.fn.tablesorter. Below go inner helper functions inside the plugin. Author: Curveball License: MIT Source: tablesorter.js, line 42 Methods &lt;inner&gt; getColIndex() Gets column's index. Source: tablesorter.js, line 166 Returns: column's index. Type number &lt;inner&gt; getValuesType() Gets column values' datatype. Source: tablesorter.js, line 157 Returns: column values' datatype. Type string &lt;inner&gt; sortAsNumbers(rowA, rowB) Sorting function. Compares two rows' cells with numeric content. Parameters: Name Type Description rowA HTMLTableRowElement one row object rowB HTMLTableRowElement another row object Source: tablesorter.js, line 129 Returns: number, depending on what value is greater given the sorting order. Type number &lt;inner&gt; sortAsStrings(rowA, rowB) Sorting function. Compares two rows' cells with textual content. Parameters: Name Type Description rowA HTMLTableRowElement one row object rowB HTMLTableRowElement another row object Source: tablesorter.js, line 143 Returns: number, depending on what value is greater given the sorting order. Type number &lt;inner&gt; sortRows() Sorts table rows. Source: tablesorter.js, line 111 Returns: Type undefined &lt;inner&gt; tablesorter(event) Handles clicks on columns' headers. Does some checks and invokes row sorting. Parameters: Name Type Description event MouseEvent event object corresponding to click on controls Source: tablesorter.js, line 66 Returns: Type undefined &lt;inner&gt; toggleBusyFlag() Toggles plugin's busy flag. Source: tablesorter.js, line 89 Returns: Type undefined &lt;inner&gt; toggleSortingOrderForCol() Toggles column's sorting order flag. Source: tablesorter.js, line 98 Returns: Type undefined × Search results Close "},"TablesorterIIFE.html":{"id":"TablesorterIIFE.html","title":"Namespace: TablesorterIIFE","body":" DocStrap Namespaces TablesorterTablesorterIIFE Namespace: TablesorterIIFE TablesorterIIFE There is an IIFE around the plugin. The IIFE contains several helper functions. The plugin gets assigned to $.fn.tablesorter. Author: Curveball License: MIT Source: tablesorter.js, line 7 Methods &lt;inner&gt; getSelector() Gets selector string passed to the plugin. Source: tablesorter.js, line 33 Returns: selector string passed to the plugin. Type string &lt;inner&gt; init(selector, context, root) Makes possible to get selector string later by attaching it to the jQuery object. Wrapper around original init() function. Parameters: Name Type Description selector string | * selector string context object an object serving as context for selectors search. The match will be searched for in its children instead of the entire page. root object usually $(document). Source: tablesorter.js, line 20 Returns: a jQuery object Type object × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
